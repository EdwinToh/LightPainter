package  com.designfission.effects{		import flash.display.MovieClip;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.media.Camera;	import flash.media.Video;		import flash.utils.Timer;	import flash.utils.ByteArray;	import flash.geom.Matrix;	import flash.net.FileReference;	import flash.events.TimerEvent;	import flash.events.MouseEvent;	import flash.events.ActivityEvent;		import org.bytearray.JPEGEncoder;	public class LightPainter extends MovieClip {				private var cam:Camera;		private var video:Video;		private var timer:Timer;				private var videoWidth:int = 640;		private var videoHeight:int = 480;				// Number of seconds to record the light painting before it stops automatically.		private var recordMaxTime:int = 3;				private var bitmapData:BitmapData;		private var newBitmapData:BitmapData;				private var holder_mc:MovieClip;				private var file:FileReference = new FileReference();				public function LightPainter(_vidWidth:int, _vidHeight:int) {			// constructor code			videoWidth = _vidWidth;			videoHeight = _vidHeight;						holder_mc = new MovieClip();		}				public function init():void {			cam = Camera.getCamera();			video = new Video(videoWidth,videoHeight);						video.attachCamera(cam);			video.smoothing = true;						// Flip videos over to achieve mirroring effect.			video.scaleX *= -1;			holder_mc.scaleX *= -1;						// Bitmap Data Setup - Created once only for memory optimization			bitmapData = new BitmapData(video.width,video.height);			newBitmapData = new BitmapData(video.width,video.height);						cam.setQuality(0,100);			cam.addEventListener(ActivityEvent.ACTIVITY, activityHandler);						//Position to dead center			video.x = videoWidth;			holder_mc.x = videoWidth;						addChild(video);			addChild(holder_mc);		}				private function activityHandler(e:ActivityEvent):void {			if(e.activating){				cam.removeEventListener(ActivityEvent.ACTIVITY, activityHandler);			}		}				public function startRecord():void {						var tempBmpData:BitmapData = new BitmapData(video.width,video.height);			tempBmpData.draw(video);			var tempBitmap:Bitmap = new Bitmap(tempBmpData);			holder_mc.addChild(tempBitmap);						timer = new Timer(10,recordMaxTime*100);			timer.addEventListener(TimerEvent.TIMER,captureImage);			timer.addEventListener(TimerEvent.TIMER_COMPLETE,stopCapture);			timer.start();					}					private function captureImage(e:TimerEvent):void {						//Grabs camera image, set its blendmode to lighten and add it over the current bitmap.			bitmapData.draw(video);			var bitmap:Bitmap = new Bitmap(bitmapData);			bitmap.blendMode = "lighten";			holder_mc.addChild(bitmap);						//Redraw the entire new screen and remove the older ones, then add it back to the holder.			newBitmapData.draw(holder_mc);			var newBitmap:Bitmap = new Bitmap(newBitmapData);			removeAllChildrenOf(holder_mc);						holder_mc.addChild(newBitmap);						}				private function removeAllChildrenOf(mc):void {			//removed while loop and just removed the 2 items I know are there to save memory.			mc.removeChildAt(0);			mc.removeChildAt(0);		}				private function stopCapture(e:TimerEvent):void {			stopRecord();		}				public function stopRecord():void {			timer.stop();		}				public function exportImage():void {			var jpgEncoder:JPEGEncoder = new JPEGEncoder(100);			newBitmapData.draw(holder_mc);						var tempBitmap:Bitmap = new Bitmap(newBitmapData);						//flip horizontal matrix			var flipHorizontalMatrix = new Matrix()			flipHorizontalMatrix.scale(-1,1)			flipHorizontalMatrix.translate(tempBitmap.width,0)						var flippedBitmap:BitmapData = new BitmapData(tempBitmap.width,tempBitmap.height,false,0xFFCC00)			flippedBitmap.draw(tempBitmap,flipHorizontalMatrix);						var ba:ByteArray = jpgEncoder.encode(flippedBitmap);			file.save(ba,'LightTracer.jpg');		}			}	}