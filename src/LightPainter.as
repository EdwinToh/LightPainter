package  {		import flash.display.MovieClip;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.media.Camera;	import flash.media.Video;		import flash.utils.Timer;	import flash.utils.ByteArray;	import flash.geom.Matrix;	import flash.net.FileReference;	import flash.events.TimerEvent;	import flash.events.MouseEvent;	import flash.events.ActivityEvent;	public class LightPainter extends MovieClip {				private var cam:Camera = Camera.getCamera();		private var video:Video;		private var timer:Timer;				private var videoWidth:int = 640;		private var videoHeight:int = 480;				// Number of seconds to record the light painting before it stops automatically.		private var recordMaxTime:int = 3;				private var bitmapData:BitmapData;		private var newBitmapData:BitmapData;				private var holder_mc:MovieClip = new MovieClip();				private var file:FileReference = new FileReference();				public function LightPainter() {			// constructor code			video = new Video(videoWidth,videoHeight);						video.attachCamera(cam);			video.smoothing = true;						// Flip videos over to achieve mirroring effect.			video.scaleX *= -1;			holder_mc.scaleX *= -1;						// Bitmap Data Setup - Created once only for memory optimization			bitmapData = new BitmapData(video.width,video.height);			newBitmapData = new BitmapData(video.width,video.height);						cam.setQuality(0,100);			cam.addEventListener(ActivityEvent.ACTIVITY, activityHandler);			stop_mc.addEventListener(MouseEvent.CLICK,clickStop);			start_mc.addEventListener(MouseEvent.CLICK,initCapture);			export_mc.addEventListener(MouseEvent.CLICK,exportImage);						//Position to dead center			video.x = stage.stageWidth/2 + (videoWidth/2);			video.y = stage.stageHeight/2 - (videoHeight/2);			holder_mc.x = stage.stageWidth/2 + (videoWidth/2);			holder_mc.y = stage.stageHeight/2 - (videoHeight/2);						addChild(video);			addChild(holder_mc);					}				private function activityHandler(e:ActivityEvent):void {			if(e.activating){				cam.removeEventListener(ActivityEvent.ACTIVITY, activityHandler);			}		}				private function initCapture(e:MouseEvent):void {						status_txt.text = "Status: Recording";						var tempBmpData:BitmapData = new BitmapData(video.width,video.height);			tempBmpData.draw(video);			var tempBitmap:Bitmap = new Bitmap(tempBmpData);			holder_mc.addChild(tempBitmap);						timer = new Timer(10,recordMaxTime*100);			timer.addEventListener(TimerEvent.TIMER,captureImage);			timer.addEventListener(TimerEvent.TIMER_COMPLETE,stopCapture);			timer.start();					}					private function captureImage(e:TimerEvent):void {						//Grabs camera image, set its blendmode to lighten and add it over the current bitmap.			bitmapData.draw(video);			var bitmap:Bitmap = new Bitmap(bitmapData);			bitmap.blendMode = "lighten";			holder_mc.addChild(bitmap);						//Redraw the entire new screen and remove the older ones, then add it back to the holder.			newBitmapData.draw(holder_mc);			var newBitmap:Bitmap = new Bitmap(newBitmapData);			removeAllChildrenOf(holder_mc);						holder_mc.addChild(newBitmap);						}				private function removeAllChildrenOf(mc):void {			//removed while loop and just removed the 2 items I know are there to save memory.			mc.removeChildAt(0);			mc.removeChildAt(0);		}				private function clickStop(e:MouseEvent):void {			stopRecord();		}				private function stopCapture(e:TimerEvent):void {			stopRecord();		}				private function stopRecord():void {			status_txt.text = "Status: Not Recording";			timer.stop();		}				private function exportImage(e:MouseEvent):void {			var jpgEncoder:JPEGEncoder = new JPEGEncoder(100);			newBitmapData.draw(holder_mc);						var tempBitmap:Bitmap = new Bitmap(newBitmapData);						//flip horizontal matrix			var flipHorizontalMatrix = new Matrix()			flipHorizontalMatrix.scale(-1,1)			flipHorizontalMatrix.translate(tempBitmap.width,0)						var flippedBitmap:BitmapData = new BitmapData(tempBitmap.width,tempBitmap.height,false,0xFFCC00)			flippedBitmap.draw(tempBitmap,flipHorizontalMatrix);						var ba:ByteArray = jpgEncoder.encode(flippedBitmap);			file.save(ba,'LightTracer.jpg');		}			}	}